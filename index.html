<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas with SVG</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background-color: #32006E;
      overflow: hidden;
    }
    .svg-container {
        width: 100vw;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
        overflow: hidden;
    }
    
    .svg-content {
        width: 100%;
        height: 100%;
    }
    canvas {
        width: 100vw;
        height: 100vh;
        border: none;
        background-color: #32006E;
        cursor: grab;
    }
    canvas:active {
        cursor: grabbing;
    }
    .unlock-controls {
      position: absolute;
      top: 20px;
      left: 20px;
      display: flex;
      gap: 10px;
      z-index: 1000;
    }

    .unlock-controls input {
      padding: 8px 12px;
      border: 2px solid rgba(255, 255, 255, 0.9);
      border-radius: 20px;
      background-color: rgba(255, 255, 255, 0.9);
      color: #32006E;
      font-size: 16px;
      outline: none;
      transition: all 0.3s ease;
    }

    .unlock-controls input:focus {
      border-color: #fff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .unlock-controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 20px;
      background-color: rgba(255, 255, 255, 0.9);
      color: #32006E;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .unlock-controls button:hover {
      background-color: #fff;
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div class="svg-container">
    <div class="svg-content">
      <canvas id="canvas"></canvas>
    </div>
  </div>
  <div class="unlock-controls">
    <input type="text" id="nameInput" placeholder="Ваше ім'я...">
    <input type="text" id="unlockInput" placeholder="Введіть код...">
    <button id="unlockButton">Розблокувати</button>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const context = canvas.getContext('2d');
    let scaleFactor = 1/3;
    let isDragging = false;
    let startX, startY;
    let offsetX = 0, offsetY = 0;
    let showCard = true;

    // Add touch variables
    let initialPinchDistance = null;
    let initialScale = null;

    // Load both images
    const boardImg = new Image();
    const cardImg = new Image();
    
    Promise.all([
      loadImage(boardImg, '/images/Board.svg'),
      loadImage(cardImg, '/images/Card - Atom lvl 1.svg')
    ]).then(() => {
      drawImages();
    });

    function loadImage(img, src) {
      return new Promise((resolve) => {
        img.onload = resolve;
        img.src = src;
      });
    }

    // Load cards data
    let cardsData;
    fetch('cards.json')
        .then(response => response.json())
        .then(data => {
            cardsData = data;
            initializeStorage();
            drawImages();
        });

    // Initialize storage for new users
    function initializeStorage() {
        const username = localStorage.getItem('username');
        if (!username) {
            return; // Wait for user to input name
        }

        if (!localStorage.getItem(`unlockedCards_${username}`)) {
            // Start with card Number 1
            localStorage.setItem(`unlockedCards_${username}`, JSON.stringify([1]));
        }
        
        if (!localStorage.getItem(`availableCards_${username}`)) {
            // Get connections from card 1
            const firstCard = cardsData.find(c => c.Number === 1);
            localStorage.setItem(`availableCards_${username}`, 
                JSON.stringify(firstCard ? firstCard.Connections : []));
        }

        // Initialize used codes array if it doesn't exist
        if (!localStorage.getItem(`usedCodes_${username}`)) {
            localStorage.setItem(`usedCodes_${username}`, JSON.stringify([]));
        }
    }

    function drawImages() {
        // Set canvas size to match viewport
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Clear the entire canvas
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        // Apply transforms for pan and zoom
        context.setTransform(scaleFactor, 0, 0, scaleFactor, offsetX, offsetY);
        
        // Draw board
        context.drawImage(boardImg, 0, 0);

        const username = localStorage.getItem('username');
        if (!username || !cardsData) return;

        // Draw rectangles for LOCKED cards
        const unlockedCards = JSON.parse(localStorage.getItem(`unlockedCards_${username}`));
        
        context.lineWidth = 10;
        context.strokeStyle = '#CC99FF';
        context.fillStyle = '#869CFF';

        cardsData.forEach(card => {
            if (!unlockedCards.includes(card.Number)) {
                roundRect(context, card.X, card.Y, card.width, card.height, 50);
            }
        });
    }

    function getEventPoint(e) {
      // Get point for both mouse and touch events
      const rect = canvas.getBoundingClientRect();
      const point = {
        x: (e.clientX || e.touches[0].clientX) - rect.left,
        y: (e.clientY || e.touches[0].clientY) - rect.top
      };
      return point;
    }

    // Add wheel event listener
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault(); // Prevent page scroll

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Convert mouse position to canvas coordinates before zoom
        const pointXBeforeZoom = (mouseX - offsetX) / scaleFactor;
        const pointYBeforeZoom = (mouseY - offsetY) / scaleFactor;

        // Determine zoom factor based on scroll direction
        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        
        // Update scale
        scaleFactor *= zoomFactor;

        // Calculate new position after zoom
        const pointXAfterZoom = pointXBeforeZoom * scaleFactor;
        const pointYAfterZoom = pointYBeforeZoom * scaleFactor;

        // Adjust offset to keep mouse point in the same place
        offsetX += mouseX - (pointXAfterZoom + offsetX);
        offsetY += mouseY - (pointYAfterZoom + offsetY);

        drawImages();
    });

    // Touch events for pinch zoom
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        // Get initial distance between touch points
        initialPinchDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        initialScale = scaleFactor;
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        
        // Calculate new distance
        const currentDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );

        if (initialPinchDistance === null) {
          initialPinchDistance = currentDistance;
        }

        // Calculate center point of the pinch
        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

        // Calculate zoom factor
        const scale = currentDistance / initialPinchDistance;
        
        // Apply zoom relative to initial scale
        scaleFactor = initialScale * scale;
        
        drawImages();
      } else if (e.touches.length === 1 && isDragging) {
        // Handle single touch drag
        const touch = e.touches[0];
        offsetX = touch.clientX - startX;
        offsetY = touch.clientY - startY;
        drawImages();
      }
    });

    canvas.addEventListener('touchend', () => {
      initialPinchDistance = null;
      initialScale = null;
      isDragging = false;
    });

    // Update mouse drag to use touch-compatible getEventPoint
    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        offsetX += (x - startX);
        offsetY += (y - startY);
        
        startX = x;
        startY = y;
        
        drawImages();
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
      canvas.style.cursor = 'grab';
    });

    function decodeUnlockCode(code, username) {
        try {
            // Convert code to numeric value
            const numericValue = parseInt(code, 36);
            
            // Extract properties
            const isCommon = (numericValue & 0x10000000) !== 0;
            const isRandom = (numericValue & 0x20000000) !== 0;
            const cardNumber = numericValue & 0xFF;
            const userHash = (numericValue >> 8) & 0xFFFF;
            const randomBits = (numericValue >> 24) & 0xFF; // Extract random bits
            
            // For individual codes, verify username
            if (!isCommon) {
                const calculatedHash = hashUsername(username) & 0xFFFF;
                if (calculatedHash !== userHash) {
                    return null; // Invalid user
                }
            }
            
            return {
                isRandom,
                cardNumber,
                randomBits
            };
        } catch {
            return null; // Invalid code
        }
    }

    function hashUsername(username) {
        let hash = 0;
        for (let i = 0; i < username.length; i++) {
            hash = ((hash << 5) - hash) + username.charCodeAt(i);
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash;
    }

    // Modify unlock button handler
    document.getElementById('unlockButton').addEventListener('click', () => {
        const username = localStorage.getItem('username');
        if (!username) {
            alert('Please enter your name first');
            return;
        }

        const input = document.getElementById('unlockInput');
        const code = input.value.trim().toUpperCase();

        // Check if code was already used
        const usedCodes = JSON.parse(localStorage.getItem(`usedCodes_${username}`) || '[]');
        if (usedCodes.includes(code)) {
            alert('This code has already been used');
            return;
        }
        
        const decodedCode = decodeUnlockCode(code, username);
        if (!decodedCode) {
            alert('Invalid code');
            return;
        }

        const availableCards = JSON.parse(localStorage.getItem(`availableCards_${username}`));
        let cardToUnlock;

        if (decodedCode.isRandom) {
            // Use the random bits to determine which card to unlock
            const index = decodedCode.randomBits % availableCards.length;
            cardToUnlock = availableCards[index];
        } else {
            cardToUnlock = decodedCode.cardNumber;
            if (!availableCards.includes(cardToUnlock)) {
                alert('This card is not available yet');
                return;
            }
        }

        // Store the used code
        localStorage.setItem(`usedCodes_${username}`, 
            JSON.stringify([...usedCodes, code]));

        const unlockedCards = JSON.parse(localStorage.getItem(`unlockedCards_${username}`));
        
        // Remove from available and add to unlocked
        localStorage.setItem(`unlockedCards_${username}`, 
            JSON.stringify([...unlockedCards, cardToUnlock]));
        
        // Update available cards
        const card = cardsData.find(c => c.Number === cardToUnlock);
        const newAvailable = availableCards
            .filter(num => num !== cardToUnlock)
            .concat(card.Connections || []);
        
        localStorage.setItem(`availableCards_${username}`, 
            JSON.stringify([...new Set(newAvailable)]));
        
        input.value = '';
        drawImages();
    });

    // Add name input handling
    document.getElementById('nameInput').addEventListener('change', (e) => {
        const username = e.target.value.trim();
        if (username) {
            localStorage.setItem('username', username);
            initializeStorage();
            drawImages();
        }
    });

    // Helper function for drawing rounded rectangles
    function roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + width, y, x + width, y + height, radius);
        ctx.arcTo(x + width, y + height, x, y + height, radius);
        ctx.arcTo(x, y + height, x, y, radius);
        ctx.arcTo(x, y, x + width, y, radius);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    // Add window resize handler to keep canvas sized to viewport
    window.addEventListener('resize', () => {
        drawImages();
    });
  </script>
</body>
</html>
